---
title: "Homing gene drive journal club"
author: "Transmission zero"
format: 
  revealjs:
    smaller: false
    margin: 0.02
    scrollable: true
editor: visual
css: styles.css
---

## What is this presentation?
-   Slides are generated in R from a meta-analysis data set and screenshots from the paper
-   Feedback on my interpretation of the paper and how best to present it is very much appreciated
-   In addition to these JCs, we intended to send slides to the original authors to allow them the opportunity to find mistakes in our interpretation of their data
-   Suggestions you make can be simultaneously applied to the code for \>80 papers: https://docs.google.com/spreadsheets/d/1kzc8SkY2fb0NEeGcFSwGPR9j_cCKWgiv9lECuCD97UI/edit?usp=sharing
-   The same analysis pipeline and figures are used for a manuscript in preparation and a webtool: https://sverkuijl.shinyapps.io/GeneDrive/
-   Currently the meta-analysis team is Sebald Verkuijl, Edward Ivimey-Cook, Nikolai Windbichler, Philip Leftwich, Michael Bonsall

```{r, include=FALSE}

rm(list = ls())

# ideally we would be able to loop this whole file for all papers
# not sure how to  do that practically without making it unreadable
# slide loops are hard to understand
slide_pub <- c("Green2023")

# Include figures
include_paper_figures <- FALSE

library(plotly)
library(data.table)
library(stringr)
library(tidyr)
library(tidyverse)
library(pander)
library(png)
library(ggalluvial)
library(htmltools)

library(cowplot)

library(ggrepel,
        include.only = c("geom_label_repel"))
library(grid,
        include.only = c("grid.newpage", "grid.draw"))

library(knitr)

# The custom figures are generated from a meta-analysis database we are developing
# From the raw data we attempt to automatically identify what conditions are tested and generate slides to show these

# Set working directory one level higher
cross_summary <- readRDS(str_c("../Processed/", "cross_summary.RDS"))

palette_list <-
  as.list(readRDS(str_c("../Processed/", "palette_list.RDS")))

# It is called in the function and needs to be in this relative folder
saveRDS(palette_list, file = str_c("Processed/", "palette_list.RDS"))

cross_summary <- readRDS(str_c("../Processed/", "cross_summary.RDS"))

factor_levels_values <-
  readRDS(str_c("../Processed/", "factor_levels_values.RDS"))
saveRDS(factor_levels_values,
        file = str_c("Processed/", "factor_levels_values.RDS"))

cross_summary <- readRDS(str_c("../Processed/", "cross_summary.RDS"))
saveRDS(cross_summary, file = str_c("Processed/", "cross_summary.RDS"))

# Here we load in the functions shared with the webtool
source(str_c("../", "functions.R"))

# Here we get the empty data structure from the first publication
cross_data <-
  readRDS(str_c("../Processed/", "data_", slide_pub[1], ".RDS"))[0, ]

# Here we append the data for the paper(s) to the empty df
for (p in slide_pub) {
  # Set working directory one level higher
  cross_data <-
    rbind(cross_data, readRDS(str_c("../Processed/", "data_", p, ".RDS")))
}


warning("we removed publication and strain as a pairing factor for this presentation")
cross_matching_selected <- cross_matching_selected[-1]
cross_matching_selected <- cross_matching_selected[!(cross_matching_selected %in% cross_matching[["Strain"]])]

# Here we create a list of variables relevant for generating the graphs
input_df_ref <- list(
  Species_Select = levels(factor(cross_data$Species)),
  # Here we list all species in the whole data set
  Promoter_Select = levels(factor(cross_data$Nuclease.Promoter.5UTR)),
  # Here we list all species in the whole data set
  F1_focus_Select = levels(factor(cross_data$D1.Zygote.Genotype)),
  Publication_Select = levels(factor(cross_data$Publication)),
  # DriveExpected_server = "Yes", # Here we specify if the data should exclude control crosses
  Exclusion_Select = cross_matching_selected,
  metric = "",
  # Here we grab the metric the user has chosen on the page
  B_server = "",
  B_norm_server = "Non-Normalised & All Data",
  B_color_server = "Species",
  F2_Somatic_Phenotype_Factors = F2_Somatic_Phenotype_Factors,
  # Need to check why this is duplicated
  F2_Exclusion_Select = F2_Somatic_Phenotype_Factors,
  # Need to check why this is duplicated
  facet_factor = NA,
  Names_List = Names_List,
  palette_list = palette_list
)

List$Species_List <- levels(factor(cross_data$Species))
List$Promoter_List <- levels(factor(cross_data$Nuclease.Promoter.5UTR))
List$F1_focus_List <- levels(factor(cross_data$D1.Zygote.Genotype))
List$Publication_List <- levels(factor(cross_data$Publication))

clarif_text <- "Meta-analysis requests for clarification for "

```

```{r, include=FALSE}

# We mix in figures from the paper that are stored in a folder
# These are given a name that indicates where they should appear
# The letter is the position in the presentation 
# the number is the order at that position 
# So A1 will always be a screeen shot of the title slides 

# Files are names according to:
# {name-number}"Title"
# The named sections will display the images with that name there in number order
```

```{r}


# Here we make a df that lists the paper screenshots
for (p in slide_pub) {
  images <- list.files(str_c("", p))
  
  image_files_df <- data.frame(
    "group" = substr(images, 1, 1),
    "index" = substr(images, 2, 3),
    "titles" = substr(images, 4, 500),
    "file" = images
  )
  
  image_files_df$titles <- str_sub(image_files_df$titles, end = -5)
  image_files_df$file <- str_c(p, "/", image_files_df$file)
  
  
  if (exists('combined_image_df')) {
    combined_image_df <- rbind(combined_image_df, image_files_df)
  } else {
    combined_image_df <- image_files_df
  }
}

create_saved_fig_slide <- function(slide_title, image_file) {
  # Inserts "## Title (auto)"
  pander::pandoc.header(slide_title, level = 2)
  
  pander::pandoc.p(str_c("![](", image_file, ")", "{fig-align=\"center\"}"))
  
  # a list, formatted as Markdown
  # adding also empty lines, to be sure that this is valid Markdown
  # pander::pandoc.p('\n')
  # pander::pandoc.list(letters[1:3])
  # pander::pandoc.p('')
}
```

```{r , eval= (include_paper_figures == TRUE), results = 'asis'}

# Title figure
df <- combined_image_df[combined_image_df$group == "T",]

if (nrow(df) != 0) {
for (i in 1:nrow(df)) {
   create_saved_fig_slide(df[i,"titles"],df[i,"file"])
}}

```

```{r , eval= (include_paper_figures == TRUE), results = 'asis'}

# Intro figures
df <- combined_image_df[combined_image_df$group == "G",]

if (nrow(df) != 0) {
for (i in 1:nrow(df)) {
   create_saved_fig_slide(df[i,"titles"],df[i,"file"])
}}
```

## High level nuclease and target features for all crosses

```{r, results='asis', fig.height = 9, fig.width = 16}

Figure <- SankeyPlot(
  Data = cross_data,
  Axis_factors =
    c(
      'Cross.Name',
      'Source',
      "Nuclease.Promoter.5UTR",
      "Nuclease.Insertion.Variant",
      "D.Target.Gene",
      "D1.Nuc.Pheno.Type"
    ),
  Fill_factor =  'Cross.Name',
  factor_levels_values = NA,
  metric = NA,
  Names_List
) + theme(legend.position = "none")

Figure

```

::: smaller
## Drive element DNA maps (blue = url) and attributes

```{r, results='asis'}
# Here we list out the metrics
# I should add in the definitions from overleaf
# We indicate if there is data for a particular metric in the paper

cross_summary_urls <- cross_summary



cross_summary_urls$Target.Locus.Sequence.Link <- str_c(
  "<a href=\"",
  cross_summary_urls$Target.Locus.Sequence.Link,
  "\">",
  cross_summary_urls$D.Target.Gene,
  "</a>"
)

cross_summary_urls$Drive.Inserted.Link <- str_c("<a href=\"",
                                                cross_summary_urls$Drive.Inserted.Link,
                                                "\">Drive",
                                                "</a>")

cross_summary_urls$Drive.Target.Alignment.Link <- str_c(
  "<a href=\"",
  cross_summary_urls$Drive.Target.Alignment.Link,
  "\">Drive:Target",
  "</a>"
)

drive_design_table <-
  cross_summary_urls[cross_summary_urls$Publication %in% slide_pub, ]

drive_design_factors <- list(
# 'Publication' = "Papers this element appears in",
# 'Misc.Factor' = "Misc feature",
  'Target.Locus.Sequence.Link' = "Target locus",
  'Drive.Inserted.Link' = "Drive",
  'Drive.Target.Alignment.Link' = "Drive:Target aligned (these Benchling links have issues)",
  'Drive.Allele.Size' = "Drive allele size",
  "D.gRNA.Promoter" = "gRNA promoter(s)",
  "D.gRNA.Target.Sequence" = "gRNA target seq",
  "D.gRNA.Scaffold" = "gRNA scaffold",
  "nonAlignment.5.Seq" = "non aligning 5\' seq",
  "nonAlignment.3.Seq" = "non aligning 3\' seq",
  "PAM.Orientation" = "gRNA PAM orientation"
)


drive_design_table <-
  drive_design_table[!duplicated(drive_design_table[, names(drive_design_factors)]), names(drive_design_factors)]

drive_design_table$Publication <- ""

for (i in 1:nrow(drive_design_table)) {
  df <- cross_summary_urls
  
  for (q in names(drive_design_factors)) {
    df <- df[drive_design_table[i, q] == df[, q], ]
    
  }
  
  drive_design_table[i, ]$Publication <-
    paste(unique(df$Publication), collapse = " | ")
  
}

drive_design_table <-
  drive_design_table[, c(which(colnames(drive_design_table) == "Publication"),
                         which(colnames(drive_design_table) != "Publication"))]

drive_design_factors <- append(drive_design_factors,
                               list('Publication' = "Papers this element appears in"))

names(drive_design_table) <-
  unlist(drive_design_factors[names(drive_design_table)])

pander::pandoc.table(drive_design_table, split.table = Inf)

```
:::

::: smaller
## Nuclease element DNA maps (blue = url) and attributes

```{r, results='asis'}


# Here we list out the metrics
# I should add in the definitions from overleaf
# We indicate if there is data for a particular metric in the paper

cross_summary_urls <- cross_summary



cross_summary_urls$nuc_comb_CDS <- str_c(
  cross_summary_urls$Nuclease.Promoter.5UTR,
  "_",
  cross_summary_urls$Nuclease.CDS,
  "_",
  cross_summary_urls$Nuclease.3UTR
)



cross_summary_urls$Nuclease.Inserted.Link <- str_c(
  "<a href=\"",
  cross_summary_urls$Nuclease.Inserted.Link,
  "\">",
  cross_summary_urls$nuc_comb_CDS,
  "</a>"
)


drive_design_table <-
  cross_summary_urls[cross_summary_urls$Publication %in% slide_pub, ]

drive_design_factors <- list(
# 'Misc.Factor' = "Misc feature",
  'Nuclease.Insertion.Variant' = "Nuclease insertion index/locus",
  'Nuclease.Inserted.Link' = "Nuclease carrying element",
  'Nuclease.Promoter.5UTR.Size' = "Promoter + 5UTR size (bp)",
  'Nuclease.Codon.Optimisation' = "Nuclease codon opt",
  'Nuclease.3UTR.Size' = "3 UTR size (bp)"
)


drive_design_table <-
  drive_design_table[!duplicated(drive_design_table[, names(drive_design_factors)]), names(drive_design_factors)]

drive_design_table$Publication <- ""

for (i in 1:nrow(drive_design_table)) {
  df <- cross_summary_urls
  
  for (q in names(drive_design_factors)) {
    df <- df[drive_design_table[i, q] == df[, q], ]
    
  }
  
  drive_design_table[i, ]$Nuclease.Insertion.Variant <-
    paste(unique(df$Nuclease.Insertion.Variant), collapse = " | ")
  
    drive_design_table[i, ]$Nuclease.Inserted.Link <-
    paste(unique(df$Nuclease.Inserted.Link), collapse = " | ")
  
    drive_design_table[i, ]$Publication <-
    paste(unique(df$Publication), collapse = " | ")
  
}

drive_design_table <-
  drive_design_table[, c(which(colnames(drive_design_table) == "Publication"),
                         which(colnames(drive_design_table) != "Publication"))]

drive_design_factors <- append(drive_design_factors,
                               list('Publication' = "Papers this element appears in"))

names(drive_design_table) <-
  unlist(drive_design_factors[names(drive_design_table)])

pander::pandoc.table(drive_design_table, split.table = Inf)

```
:::

## Cross types (sex/nuclease;gRNA)

```{r, results='asis', fig.height = 9, fig.width = 16}



Figure <- SankeyPlot(
  Data = cross_data,
  Axis_factors =
    c(
      'Cross.Name',
      'Source',
      "D1.Sex",
      "F1.NG_Unsorted",
      "D0.Nuclease.Sex",
      "D0.NG_Unsorted"
    ),
  Fill_factor =  'Cross.Name',
  factor_levels_values = NA,
  metric = NA,
  Names_List
) + theme(legend.position = "none")

Figure

```

```{r , eval= (include_paper_figures == TRUE), results = 'asis'}

# Construct(gene) overview figure
df <- combined_image_df[combined_image_df$group == "I",]

if (nrow(df) != 0) {
for (i in 1:nrow(df)) {
   create_saved_fig_slide(df[i,"titles"],df[i,"file"])
}
}
```

::: smaller
## What gene drive associated metrics were we able to record for this paper (null = absent)

```{r, results='asis'}

# Here we list out the metrics
# I should add in the definitions from overleaf
# We indicate if there is data for a particular metric in the paper

definitions <-
  as.list(readRDS(str_c("../Processed/", "definitions.RDS")))
factors_table <- data.frame(
  Metric = names(factor_levels_values),
  Description = as.character(definitions[names(factor_levels_values)]),
  Values.in.paper = names(factor_levels_values)
)

for (i in factors_table[, 'Metric']) {
  factors_table$Values.in.paper[factors_table$Metric == i] <-
    paste(unique(cross_data[, i]), collapse = "<br>")
  
  if (length(unique(cross_data[, i])) > 1) {
    factors_table$Values.in.paper[factors_table$Metric == i] <-
      str_c(
        "<font color=",
        '"',
        "color:green",
        '"',
        ">",
        factors_table$Values.in.paper[factors_table$Metric == i],
        "</font>"
      )
  }
}

factors_table$Metric <- as.character(unlist(Names_List[factors_table$Metric]))

# Here we list out 'pairing' factors
# We indicate what levels are recorded for these factors
# We also highlight if the factor levels are unique

pander::pandoc.table(factors_table, split.table = Inf, split.cells =  c(25,50,10))

```
:::

::: smaller
## The subset of factors we deem essential for comparing data (next slides are figures of those that vary)

```{r, results='asis'}

# need to make a separate one for the somatic phenotype stuff

definitions <-
  as.list(readRDS(str_c("../Processed/", "definitions.RDS")))
factors_table <- data.frame(
  Factor = c(names(cross_matching[cross_matching_selected]), F2_Somatic_Phenotype_Factors),
  Description = as.character(definitions[c(names(cross_matching[cross_matching_selected]), F2_Somatic_Phenotype_Factors)]),
  Levels = c(names(cross_matching[cross_matching_selected]), F2_Somatic_Phenotype_Factors)
)


for (i in factors_table[, 'Factor']) {
  factors_table$Levels[factors_table$Factor == i] <-
    paste(unique(cross_data[, i]), collapse = "<br>")
  
  if (length(unique(cross_data[, i])) > 1) {
    factors_table$Levels[factors_table$Factor == i] <-
      str_c("<font color=",
            '"',
            "color:green",
            '"',
            ">",
            factors_table$Levels[factors_table$Factor == i],
            "</font>")
    
  }
}
# Here we list out 'pairing' factors
# We indicate what levels are recorded for these factors
# We also highlight if the factor levels are unique

pander::pandoc.table(factors_table, split.table = Inf, split.cells =  c(10,100,25))

```
:::

<!-- ## How to interpret the next images? -->

<!-- -   Text explaining how the figures work (get from overleaf) -->

<!-- -   Hover your mouse over a data point for more info -->

<!-- -   Crosses considered replicates are merged -->

<!-- -   Gray lines are drawn between 'paired' crosses -->

<!-- -   Circle size is proportional to the number of progeny scored -->

<!-- -   Only show crosses with 'paired' data for the F2 factors -->

<!-- -   Figure out why the strain isn't showing -->

```{r, fig.height = 18, fig.width = 32, include=FALSE, results = 'asis'}

definitions <- append(definitions, list(Sankey = "In the data selection Sankey diagrams, the green labels and columns indicate values considered positive for the metric being measured. The blue labels and columns indicate values that are negative but are still valid and necessary to calculate an overall rate. Red labels and columns indicate values that cause those F2 counts to be excluded, and black labels and columns indicate neutral values that do not affect the metric calculation. If one or more values cause data to be excluded, the streams between columns representing those progeny are coloured red.", F2_Count = "F2 count."))

### loop over the metrics, and factors
### then produce figures for each

widget_list <- list()
Title_vec <- character()
Metric_vec <- character()
Factor_vec <- character()

for (metric in names(factor_levels_values)) {
  if (length(unique(cross_data[, metric])) > 1) {
    #& metric != "Drive_Allele_Inheritance_With_Controls") {
    
    # Here we copy the references values before we change them
    input_df <- input_df_ref
    
    # If the metric is somatic phenotype, we modify the factors
    if (metric == "Nuclease_Induced_Phenotype") {
      factor_list_custom <- c("ID",
                              #"Cross",
                              F2_Somatic_Phenotype_Factors,
                              names(cross_matching[cross_matching_selected]))
      
      factor_list_custom <-
        factor_list_custom[!(factor_list_custom %in% "D1.Sex")]
      
    } else {
      factor_list_custom <- c("ID", #"Cross",
                              names(cross_matching[cross_matching_selected]))
    }

    for (factor in factor_list_custom) {
      if (length(unique(cross_data[cross_data[, metric] != "Null", factor])) > 1 | factor == "ID") {
        
        # Y axis metric
        input_df$metric <- metric
        
        # X axis metric
        input_df$B_server <- factor
        
        
        Figure_List <- Comparison_Function(
          cross_data,
          cross_matching,
          input_df,
          "Interactive",
          List,
          factor_levels_values
        )
        
        Figure_List$Plot <- Figure_List$Plot %>%
          layout(
            autosize = T,
            width = 16 * 65,
            height = 10 * 55,
            paper_bgcolor = "white",
            xaxis = list(
              tickfont = list(size = 15),
              titlefont = list(size = 20)
            ),
            yaxis = list(
              tickfont = list(size = 15),
              titlefont = list(size = 20)
            )
          )

        
        if (factor == factor_list_custom[1]) {
          
                widget_list[[length(widget_list) + 1]] <- Figure_List$Sankey
                Title_vec <- c(Title_vec, str_c(metric, " inclusion criteria"))
                Factor_vec <- c(Factor_vec, "Sankey")
                Metric_vec <- c(Metric_vec, "F2_Count")
        }

        widget_list[[length(widget_list) + 1]] <- htmltools::div(htmltools::tagList(Figure_List$Plot), style = "height: 575px", fig.align='center')
        Title_vec <- c(Title_vec, str_c(metric, ":", factor))
        Factor_vec <- c(Factor_vec, factor)
        Metric_vec <- c(Metric_vec, metric)
        
      }
    }
  }
}


# htmltools::tagList(widget_list)

# This is stupidly verbose, but...
# Spent too many hours trying to make this work in a loop
# It just wont...
# same for if statements
# this is so annoying and illogical

i <- 1
widgets_numb <- length(widget_list)

# Change the tiles to the long text version
# maybe add the definitions of the metric and factor at the bottom of the graphs
# add a caption about the lines being drawn
# add the Sankey plots in between the different factors (probably quite hard)

Line_meaning <- "Lines are drawn between paired crosses that are identical for the other essential factors, apart from the respective X-axis factor."

```

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

::: smaller
```{r , eval= (i <= widgets_numb), results = 'asis'}
pander::pandoc.header(Title_vec[i], level = 2)
widget_list[[i]]
pander::pandoc.p(str_c("X-axis: ", definitions[Factor_vec[i]], ""))
pander::pandoc.p(str_c("Y-axis: ", definitions[Metric_vec[i]], ""))
if (Factor_vec[i] != "Sankey") {
pander::pandoc.p(str_c("O-O: ", Line_meaning, ""))  
}
i <- i + 1
```
:::

```{r , eval= (include_paper_figures == TRUE), results = 'asis'}

# Construct(gene) overview figure
df <- combined_image_df[combined_image_df$group == "C",]

if (nrow(df) != 0) {
for (i in 1:nrow(df)) {
   create_saved_fig_slide(df[i,"titles"],df[i,"file"])
}
}
```

```{r , eval= (include_paper_figures == TRUE), results = 'asis'}

# Construct(gene) overview figure
df <- combined_image_df[combined_image_df$group == "E",]

if (nrow(df) != 0) {
for (i in 1:nrow(df)) {
   create_saved_fig_slide(df[i,"titles"],df[i,"file"])
}
}
```

```{r , eval= (include_paper_figures == TRUE), results = 'asis'}

# Construct(gene) overview figure
df <- combined_image_df[combined_image_df$group == "M",]

if (nrow(df) != 0) {
for (i in 1:nrow(df)) {
   create_saved_fig_slide(df[i,"titles"],df[i,"file"])
}
}
```

```{r , eval="Carballar-Lejarazú2020" %in% slide_pub, results = 'asis'}

pander::pandoc.header(str_c(clarif_text, "Carballar-Lejarazú2020"), level = 2)

pander::pandoc.p(str_c("* ", "Could you provide the pCO37 plasmid map."))
pander::pandoc.p(str_c("* ", "\"To determine if indel alleles were present in the germline of tear mosquitoes, four intercrosses (IX) were performed with tear phenotype mosquitoes recovered from [...] in addition to IX-2 (14 males and 16 females) of the maternal-effect experiments (Table S6).\" Is the drive status of the grandparents known for the IX-2 intercross listed in tabel 6?"))

pander::pandoc.p(str_c("* ", "You describe the cardinal KO and Tear phenotype in the sex lineage crosses (Table3). Were individuals with a WT phenotype specifically selected for follow-up crosses? Put differently, if 8% of a cross present with a tear phenotype were nonetheless progeny with all WT phenotypes selected for follow-up crosses?"))

pander::pandoc.p(str_c("* ", "The CFP+, KO, and Tear rates are listed seperately. Can we assume that the KO and Tear phenotype were only found among the CFP+ progeny?"))

pander::pandoc.p(str_c("* ", "Note about exclusion: Most of the crosses in Table S6 not included because they come from the cage trial. Only IX-2 is included as it came from the maternal-effect experiments."))

```

```{r , eval="Carballar-Lejarazú2023" %in% slide_pub, results = 'asis'}

pander::pandoc.header(str_c(clarif_text, "Carballar-Lejarazú2023"), level = 2)

pander::pandoc.p(str_c("* ", "\"pTP13 is ~20 kilobase pairs (kb) in length, of which ~15.6 kb comprises the drive system components, dominant marker gene, and scFvs.\" The sequences in Table S31. add up to just under 15Kb. Could you provide the pTP13 plasmid map?"))

pander::pandoc.p(str_c("* ", "\"For the \"founder\" experiments (Table 1 and TableS3) the CFP+, KO, and Tear rates are listed separately. Can we assume that the KO and Tear phenotype were among the CFP+ progeny?"))

pander::pandoc.p(str_c("* ", "You describe the cardinal KO and Tear phenotype. Were individuals with a particular phenotype (i.e., WT) specifically selected for follow-up crosses?"
                       ))

pander::pandoc.p(str_c("* ", "Note about exclusion: TableS2 G2 OX/IX was excluded becuase the female parents are a mix of WT and AgTP13."
                       ))

pander::pandoc.p(str_c("* ", "Three replicates are described for pooled data shown in Table1, TableS3, TableS4 and TableS5. Could you provide the data for these individuals replicates before they were pooled? "))

```

```{r , eval="Green2023" %in% slide_pub, results = 'asis'}

pander::pandoc.header(str_c(clarif_text, "Green2023"), level = 2)

pander::pandoc.p(str_c("* ", "\"Fortunately, we also recovered a minority of knock-in larvae that had integrated the Lp-GD construct as expected, marked with DsRedNLS only (Suppl. Fig. 1A). However, no evidence of gene drive was observed in further generations, as DsRed inheritance did not exceed 50% when crossing heterozygotes to WT.\" \n Do you have integer progeny counts for these crosses? Our database framework does not allow us to incorporate data with only percentages."))

pander::pandoc.p(str_c("* ", "\"To distinguish among these possibilities, we generated females carrying single heterozygous copies of the three unlinked transgenes SagGDzpg, Lp::Sc2A10 and a non-fluorescent (puromycin resistance marked) vasa-Cas9. The progeny of these triple-transgenic females crossed to WT males showed markedly better homing rates (>79 % GFP inheritance) (Fig. 4B).\" \n To account for possible deposition, could you let us know what cross was performed to create these triple-hets (e.g., female Lp-210/Lp-210; Saglin-GD/Saglin-GD X male vasa-Cas9/vasa-Cas9)?"))

pander::pandoc.p(str_c("* ", "Would you be able to provide the plasmid map for the non-fluorescent (puromycin resistance marked) vasa-Cas9?"))

pander::pandoc.p(str_c("* ", "\"Approximate gating completed with visual examination of a sample of 200 larvae suggested 54.1% DsRed inheritance at the Saglin locus, an even more modest inheritance bias than for GFP at the Lp locus.\" \n Our database framework does not allow us to incorporate data with only percentages and it is not possible to directly get 54.1% from N/200. Could you provide the integer values?"))

pander::pandoc.p(str_c("* ", "\"We then sought to examine the homing rates at the two loci at a larger scale, using COPAS flow cytometry to analyse the progeny from [SagGDvasa /Y ; Lp::Sc2A10/+] males backcrossed en masse to wild-type females, and from [SagGDvasa /+ ; Lp::Sc2A10/+] females backcrossed en masse to wild-type males. The male cross yielded only 405 larvae, of which 391 were GFP positive (GFP inheritance: 96.5%, corresponding to a homing rate of 93%). DsRed on the X chromosome was, as expected, passed on to 50% of the progeny (daughters). The female cross yielded 5197 larvae showing 95.1% GFP inheritance and 80.7% DsRed inheritance, corresponding to homing rates of 90.2% at the Lp locus and 61.4% at the Saglin locus.\" \n To account for possible deposition, could you let us know what cross was performed to create these hets?"))

```
